#pragma kernel Density
#include "Includes/noiseSimplex.cginc"

RWStructuredBuffer<float> densities;
int3 localPosition;
uint3 latticeSize;
float squashingFactor;
float midHeight;

int indexFromCoord(uint x, uint y, uint z, uint3 grid_size)
{
    return z * grid_size.x * grid_size.y +
           y * grid_size.x +
           x;
}

float FractalNoise3D(float3 position, int octaves, float scale)
{
    position += float3(123.456, 789.123, 456.789);
    position *= 1/scale;
    
    float noiseSum = 0;
    float amplitude = 1;
    float frequency = 1;

    for (int i = 0; i < octaves; i++)
    {
        noiseSum += snoise(position * frequency) * amplitude;
        
        frequency *= 2;
        amplitude *= 0.5f;
    }
    return noiseSum;
}

[numthreads(8, 8, 8)]
void Density (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= latticeSize.x || id.y >= latticeSize.y || id.z >= latticeSize.z)
    {
        return;
    }
    
    float3 position = id + localPosition;
    //                                vv CENTER
    float squash = -length(position - float3(32, 32, 32)) * squashingFactor + midHeight * squashingFactor;
    
    float noise = FractalNoise3D(position, 3, 64) + squash;
    
    int index = indexFromCoord(id.x, id.y, id.z, latticeSize);
    densities[index] = noise;
}

//float SphereSurfaceNoise(Vector3 position, float min_height, float max_height, float noise_scale, int octaves) // noise for flat hilly terrain on the surface of a sphere
//{
//    float noise = Noise3D((position).normalized + seed_position / 10f, noise_scale, octaves);
//    float t = (noise + 1) / 2f;
//    float surface_height = Mathf.Lerp(min_height, max_height, height_map.Evaluate(t));
//
//    float radius = (position).magnitude;
//
//    float density = (radius - surface_height) / (max_height - min_height) * 2;
//
//    return density;
//
//}

